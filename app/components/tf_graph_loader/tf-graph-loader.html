<dom-module id="tf-graph-loader"></dom-module>

 <script>
    Polymer({

        is: 'tf-graph-loader',

        properties: {

            progress: {
                type: Object,
                notify: true
            },

            filter: {
                type: Object,
                notify: true
            },

            outGraphHierarchy: {
                type: Object,
                readOnly: true, //readonly so outsider can't change this via binding
                notify: true
            },

            outGraph: {
                type: Object,
                readOnly: true, //readonly so outsider can't change this via binding
                notify: true
            },

            outHierarchyParams: {
                type: Object,
                readOnly: true,
                notify: true
            },

            currentProject: {
                type: Object,
                notify: true,
                observer: '_currentProjectChanged'
            }
        },

        _currentProjectChanged: function(newProject, oldProject) {
            var project = newProject;

            console.info("_currentProjectChanged: " + project);
            this.set('progress', {
                value: 0,
                msg: ''
            });

            var hierarchyParams = {
                verifyTemplate: false,
                // If a set of numbered op nodes has at least this number of nodes then group them into a series node.
                seriesNodeMinSize: 6,
                // A map of series node names to series grouping settings, to indicate if a series is to be rendered as grouped or ungrouped. Starts out empty which allows the renderer to decide which series are initially rendered grouped and which aren't.
                seriesMap: {}
            };

            this._setOutHierarchyParams(hierarchyParams);

            var tracker = tf.graph.util.getTracker(this);
            var readDataTracker = tf.graph.util.getSubtaskTracker(tracker, 70, 'Reading Data');
            var graphTracker = tf.graph.util.getSubtaskTracker(tracker, 30, 'Building graph');
            // var hierarchyTracker = tf.graph.util.getSubtaskTracker(tracker, 15, 'Namespace hierarchy');

            var buildParams = {
                enableEmbedding: false,
                inEmbeddingTypes: [],
                outEmbeddingTypes: [],
                refEdges: {}
            };

            this.filter.reset();

            kt.parser.readAndParse(readDataTracker)
            .then(function(project) {
                this.fire("project-loaded", {});
                return this.rebuildGraph(project, graphTracker);

            }.bind(this));
        },

        rebuildGraph: function(project, tracker) {

            var hierarchyParams = {
                verifyTemplate: false,
                // If a set of numbered op nodes has at least this number of nodes then group them into a series node.
                seriesNodeMinSize: 6,
                // A map of series node names to series grouping settings, to indicate if a series is to be rendered as grouped or ungrouped. Starts out empty which allows the renderer to decide which series are initially rendered grouped and which aren't.
                seriesMap: {}
            };

            this._setOutHierarchyParams(hierarchyParams);

            var graphTracker = tf.graph.util.getSubtaskTracker(tracker, 50, 'Linking nodes');
            var hierarchyTracker = tf.graph.util.getSubtaskTracker(tracker, 50, 'Namespace hierarchy');

            var buildParams = {
                enableEmbedding: false,
                inEmbeddingTypes: [],
                outEmbeddingTypes: [],
                refEdges: {}
            };

            this.filter.reset();

            var nodes = kt.parser.buildGraph(project.proofObligations, project.apis);
            // this.fire("project-loaded", {});
            tf.graph.build(nodes, buildParams, graphTracker).then(function(graph) {
                this._setOutGraph(graph);
                return tf.graph.hierarchy.build(graph, hierarchyParams, hierarchyTracker);

            }.bind(this)).then(function(graphHierarchy) {
                // Update the properties which notify the parent with the graph hierarchy
                this._setOutGraphHierarchy(graphHierarchy);
            }.bind(this)).catch(function(e) {
                // Generic error catch, for errors that happened outside asynchronous tasks.
                tracker.reportError("Graph visualization failed: " + e, e);
            });
        }
    });
</script>
