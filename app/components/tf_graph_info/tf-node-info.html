<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../bower_components/paper-item/all-imports.html">

<link rel="import" href="../../static/icons/icons.html">

<link rel="import" href="node-icon.html">

<link rel="import" href="tf-node-list-item.html">
<link rel="import" href="discharge-info.html">

<dom-module id="tf-node-info">
    <style></style>
    <template>
        <div>

            <div class="node-color-container">

                <node-icon id="bg" node="[[_node]]" render-info="[[_getRenderInfo(nodeName, renderHierarchy)]]" color-by="[[colorBy]]"></node-icon>

                <div id="caption">
                    <paper-icon-button icon="{{_getToggleIcon(_expanded)}}" on-click="_toggleExpanded" class="toggle-button"></paper-icon-button>
                    <div ><iron-icon icon="kt:location-on"></iron-icon><span id="nodetitle"></span> <span class='location'>
                        [[_funcLocation]]</span></div>
                </div>
            </div>

            <div class="po">

                <template is="dom-if" if="[[_predicate]]">
                    <div class='predicate'>
                        <sup>
                            <span class='level'></span>
                        </sup>
                        <span id="predicate-name">
                            [[_predicate]]
                        </span>
                        <template is="dom-if" if="[[_predicateArgument]]">
                            (<span id="predicate-arg">
                                [[_predicateArgument]]
                            </span>)

                        </template>

                    </div>
                </template>


                <template is="dom-if" if="{{_node.metagraph}}">
                    <div class="subtitle">
                        Subgraph:
                        <span>[[_node.cardinality]]</span>
                        nodes
                    </div>
                </template>

            </div>

            <div>

                <template is="dom-if" if="{{_node.op}}">

                    <div class$="[[_node_class]]">

                        <template is="dom-if" if="{{_attributes.apiId}}">
                            <div id='api-id'>api-id: [[_attributes.apiId]]</div>
                        </template>


                        <discharge-info node="[[_node]]">
                        <discharge-info>


                    </div>

                </template>

                <iron-collapse opened="{{_expanded}}">
                    <template is="dom-if" if="{{_expanded}}" restamp="true">
                        <div class="expandedInfo">

                            <div class="sub-list-group predecessors">
                                <span class="caption">Dependent PO (<span>[[_totalPredecessors]]</span>)</span>

                                <iron-list class="sub-list" id="inputsList" items="[[_predecessors.regular]]">
                                    <template>
                                        <tf-node-list-item
                                            class="non-control-list-item"
                                            card-node="[[_node]]"
                                            item-node="[[item.node]]"
                                            edge-label="[[item.edgeLabel]]"
                                            item-render-info="[[item.renderInfo]]"
                                            name="[[item.name]]"
                                            item-type="predecessors"
                                            color-by="[[colorBy]]"
                                            apiId="[[item.node.attr.apiId]]"></tf-node-list-item>
                                    </template>
                                </iron-list>

                            </div>

                            <div class="sub-list-group successors">
                                <span class="caption">Depends on (<span>[[_totalSuccessors]]</span>)</span>
                                <iron-list class="sub-list" id="outputsList" items="[[_successors.regular]]">
                                    <template>
                                        <tf-node-list-item
                                            class="non-control-list-item"
                                            card-node="[[_node]]"
                                            item-node="[[item.node]]"
                                            edge-label="[[item.edgeLabel]]"
                                            item-render-info="[[item.renderInfo]]"
                                            name="[[item.name]]"
                                            apiId="[[item.node.attr.apiId]]"
                                            item-type="successor"
                                            color-by="[[colorBy]]"></tf-node-list-item>
                                    </template>
                                </iron-list>

                            </div>
                        </div>
                    </template>
                </iron-collapse>
            </div>

    </template>



    <script>
        (function() {
            Polymer({
                is: 'tf-node-info',

                properties: {
                    nodeName: String,
                    graphHierarchy: Object,
                    renderHierarchy: Object,
                    /** What to color the nodes by (compute time, memory, device etc.) */
                    colorBy: String,
                    _node: {
                        type: Object,
                        computed: '_getNode(nodeName, graphHierarchy)',
                        observer: '_resetState'
                    },
                    _funcLocation: {
                        type: String,
                        computed: '_getFuncLocation(_node)'
                    },
                    _node_class: {
                        type: String,
                        computed: '_getNodeClass(_node)'
                    },
                    // The enum value of the include property of the selected node.
                    nodeInclude: {
                        type: Number,
                        observer: '_nodeIncludeStateChanged'
                    },
                    _attributes: {
                        type: Object,
                        computed: '_getAttributes(_node)'
                    },
                    _predicate: {
                        type: String,
                        computed: '_getPredicate(_node)'
                    },
                    _device: {
                        type: String,
                        computed: '_getDevice(_node)'
                    },
                    _successors: {
                        type: Object,
                        computed: '_getSuccessors(_node, graphHierarchy)'
                    },
                    _predicateArgument: {
                        type: String,
                        computed: '_getPredicateArgument(_node)'
                    },
                    _predecessors: {
                        type: Object,
                        computed: '_getPredecessors(_node, graphHierarchy)'
                    },
                    _subnodes: {
                        type: Array,
                        computed: '_getSubnodes(_node)'
                    },
                    _expanded: {
                        type: Boolean,
                        value: true
                    },
                    _totalPredecessors: {
                        type: Number,
                        computed: '_getTotalPred(_predecessors)'
                    },
                    _totalSuccessors: {
                        type: Number,
                        computed: '_getTotalSucc(_successors)'
                    },
                    _openedControlPred: {
                        type: Boolean,
                        value: false
                    },
                    _openedControlSucc: {
                        type: Boolean,
                        value: false
                    },
                    _auxButtonText: String,
                    _groupButtonText: String
                },
                _getPredicate: function(node) {
                    return kt.graph.getPredicate(node);
                },
                expandNode: function() {
                    this.fire('_node.expand', this.node);
                },
                _getNode: function(nodeName, graphHierarchy) {
                    return graphHierarchy.node(nodeName);
                },
                _getPrintableHTMLNodeName: function(nodeName) {
                    // Insert an optional line break before each slash so that long node names wrap cleanly at path boundaries.
                    return (nodeName || '').replace(/\//g, '<wbr>/');
                },
                _getRenderInfo: function(nodeName, renderHierarchy) {
                    return this.renderHierarchy.getOrCreateRenderNodeByName(nodeName);
                },

                _getFuncLocation(node) {
                    if (node && node.attr && node.attr.location)
                        return ":"+node.attr.location[0][0];
                    return "";
                },

                _getAttributes: function(node) {
                    this.async(this._resizeList.bind(this, "#attributesList"));
                    if (!node || !node.attr) {
                        return {};
                    }

                    return node.attr;
                },

                _getPredicateArgument: function(node) {
                    symbol = this._getAttributes(node)["symbol"];
                    if (symbol) {
                        if (symbol.type == "ID") {
                            return symbol.value;
                        } else {
                            return '"' + symbol.value + '"';
                        }
                    } else {
                        return "";
                    }
                },

                _getNodeClass: function(node) {
                    if (node && node.attr) {
                        return "po level-" + node.attr.level + " state-" + node.attr.state;
                    } else {
                        return "po";
                    }
                },
                _getDevice: function(node) {
                    return node
                        ? node.device
                        : null;
                },
                _getSuccessors: function(node, hierarchy) {
                    this.async(this._resizeList.bind(this, "#inputsList"));
                    if (!node) {
                        return {regular: [], control: []}
                    }
                    return this._convertEdgeListToEdgeInfoList(hierarchy.getSuccessors(node.name), false, node.isGroupNode);
                },
                _getPredecessors: function(node, hierarchy) {
                    this.async(this._resizeList.bind(this, "#outputsList"));
                    if (!node) {
                        return {regular: [], control: []}
                    }
                    return this._convertEdgeListToEdgeInfoList(hierarchy.getPredecessors(node.name), true, node.isGroupNode);
                },
                _convertEdgeListToEdgeInfoList: function(list, isPredecessor, isGroupNode) {

                    /**
           * Unpacks the metaedge into a list of base edge information
           * that can be rendered.
           */
                    var unpackMetaedge = function(metaedge) {
                        return _.map(metaedge.baseEdgeList, function(baseEdge) {
                            name = isPredecessor
                                ? baseEdge.v
                                : baseEdge.w;
                            return {
                                name: name,
                                node: this._getNode(name, this.graphHierarchy),
                                edgeLabel: null,
                                renderInfo: this._getRenderInfo(name, this.renderHierarchy)
                            };
                        }, this);
                    }.bind(this);

                    /**
           * Converts a list of metaedges to a list of edge information
           * that can be rendered.
           */
                    var toEdgeInfoList = function(edges) {
                        var edgeInfoList = [];
                        _.each(edges, function(metaedge) {
                            var name = isPredecessor
                                ? metaedge.v
                                : metaedge.w;
                            // Enumerate all the base edges if the node is an OpNode, or the metaedge has only 1 edge in it.
                            if (!isGroupNode || metaedge.baseEdgeList.length == 1) {
                                edgeInfoList = edgeInfoList.concat(unpackMetaedge(metaedge));
                            } else {
                                edgeInfoList.push({
                                    name: name,
                                    node: this._getNode(name, this.graphHierarchy),
                                    edgeLabel: tf.graph.scene.edge.getLabelForEdge(metaedge, this.renderHierarchy),
                                    renderInfo: this._getRenderInfo(name, this.renderHierarchy)
                                });
                            }
                        }, this);
                        return edgeInfoList.sort(
                            function(x, y) {
                                if (x.node.attr && y.node.attr) {
                                    return kt.graph.compareStates(x.node.attr.state, y.node.attr.state)
                                } else {
                                    return -1;
                                }
                            });

                        // return edgeInfoList;
                    }.bind(this);

                    return {
                        regular: toEdgeInfoList(list.regular),
                        control: toEdgeInfoList(list.control)
                    };
                },
                _getSubnodes: function(node) {
                    return node && node.metagraph
                        ? node.metagraph.nodes()
                        : null;
                },
                _getTotalPred: function(predecessors) {
                    return predecessors.regular.length + predecessors.control.length;
                },
                _getTotalSucc: function(successors) {
                    return successors.regular.length + successors.control.length;
                },
                _toggleControlPred: function() {
                    this._openedControlPred = !this._openedControlPred;
                },
                _toggleControlSucc: function() {
                    this._openedControlSucc = !this._openedControlSucc;
                },
                _toggleExpanded: function() {
                    this._expanded = !this._expanded;
                },
                _getToggleIcon: function(expanded) {
                    return expanded
                        ? "expand-less"
                        : "expand-more";
                },
                _resetState: function() {
                    this._openedControlPred = false;
                    this._openedControlSucc = false;

                    this.set("_groupButtonText", tf.graph.scene.node.getGroupSettingLabel(this._node));

                    if (this._node) {
                        var title = kt.graph.getLocationPath(this._node);
                        Polymer.dom(this.$.nodetitle).innerHTML = this._getPrintableHTMLNodeName(title);
                    }
                },
                _resizeList: function(selector) {
                    var list = document.querySelector(selector);
                    if (list) {
                        list.fire('iron-resize');
                    }
                },
                _toggleInclude: function() {
                    var graphElem = document.querySelector("#graph");
                    graphElem.fire("node-toggle-extract", {name: this.nodeName});
                    var graphBoardElem = document.querySelector("#graphboard");
                    graphBoardElem.fire("node-toggle-extract");
                },
                _nodeIncludeStateChanged: function(include, oldInclude) {
                    this.set("_auxButtonText", tf.graph.getIncludeNodeButtonString(include));
                },
                _toggleGroup: function() {
                    var graphElem = document.querySelector("#graph");
                    var seriesName = tf.graph.scene.node.getSeriesName(this._node);
                    graphElem.fire("node-toggle-seriesgroup", {name: seriesName});
                },
                _isInSeries: function(node) {
                    return tf.graph.scene.node.canBeInSeries(node);
                }
            });
        })();
    </script>
</dom-module>
