<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html" />
<link rel="import" href="../../../bower_components/paper-input/paper-input.html" />
<link rel="import" href="../../../bower_components/paper-menu-button/paper-menu-button.html" />
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html" />

<dom-module id="c-apply">
    <style>
        :host {
            --button-padding: 8px;
            --button-margin: 0.29em;
        }

        .group {
            @apply --layout-horizontal;
            @apply --layout-center;
        }

        .button-padding {
            padding: var(--button-padding)
        }

        .nested-expression-bg {
            background: rgba(100, 120, 255, 0.15);
        }

        .nested-expression {
            margin: calc( var(--button-margin) + 8px);
            margin-top: - var(--button-margin);
            border: 1px solid gainsboro;
            padding-top: 10px;
        }
    </style>

    <template>
        <!-- <small>
            <pre>[[_debug]]</pre>
        </small> -->


        <div class="group">
            <div>
                <paper-menu-button class="button-padding" id="rel_btn" no-animations close-on-activate>
                    <paper-button raised slot="dropdown-trigger" class$="[[_getOperandBtnClass(selectedOperandIndex1)]]">[[_getOperandDisplayName(selectedOperandIndex1)]]</paper-button>
                    <paper-listbox slot="dropdown-content" selected="{{selectedOperandIndex1}}">
                        <template is="dom-repeat" items="[[operandTypes]]">
                            <paper-item>[[_getOperandDisplayName(index)]]</paper-item>
                        </template>
                    </paper-listbox>
                </paper-menu-button>

                <template is="dom-if" if="[[apply.field]]">
                    <paper-input class="button-padding" label="Field name" value="{{apply.field.fname}}"></paper-input>
                </template>

                <template is="dom-if" if="[[apply.apply]]">
                    <div class="nested-expression nested-expression-bg">
                        <h3>Addressed Value:</h3>
                        <c-apply apply="[[apply.apply]]"></c-apply>
                    </div>
                </template>
            </div>


            <!-- RELATION -->

            <template is="dom-if" if="[[not(binary)]]">
                <paper-button>is</paper-button>
            </template>

            <paper-menu-button class="flex" id="rel_btn" no-animations close-on-activate>
                <paper-button raised slot="dropdown-trigger">[[_relationDisplayName(_computedRelation)]]</paper-button>
                <paper-listbox slot="dropdown-content" selected="{{selectedRelation}}">
                    <template is="dom-repeat" items="[[relations]]">
                        <paper-item>[[_relationDisplayName(index)]]</paper-item>
                    </template>
                </paper-listbox>
            </paper-menu-button>



            <!-- Operand 2 -->
            <template is="dom-if" if="[[binary]]">
                <paper-input class="flex" label="Numeric constant" value="{{apply.cn}}"></paper-input>
            </template>

        </div>



        <!-- <paper-checkbox checked="{{apply.field}}">Field Value</paper-checkbox> -->











    </template>



    <script>
        Polymer({
            is: 'c-apply',

            observers: [
                'formulaChanged(apply.*)'
            ],

            _getOperandBtnClass(selectedOperandIndex1) {
                if (selectedOperandIndex1 == 2) {
                    return "nested-expression-bg"
                }
                return "";
            },

            _getOperandDisplayName: function (idx) {
                if (idx === 0) {
                    let ret = "field";
                    if (this.apply.field && this.apply.field.fname) {
                        return "field :" + this.apply.field.fname + "";
                    } else {
                        return "Field.."
                    }
                } else if (idx === 1) {
                    return "Return Value"
                }
                else if (idx === 2) {
                    return "Addressed Value.."
                }
            },

            properties: {



                operandTypes: {
                    type: Array,
                    value: ["field", "return", "expression"]
                },

                relations: {
                    type: Array,
                    value: () => Contracts.RELATIONS
                },

                _binaryRelations: {
                    type: Array,
                    value: () => Contracts.BINARY_RELATIONS
                },

                apply: {
                    type: Object,
                    // observer: '_onFormulaChanged',
                    notify: true
                },

                selectedRelation: {
                    type: Number,
                    // value: -1,
                    observer: "_onSelectedRelation"
                },

                selectedOperandIndex1: {
                    type: Number,
                    // value: -1,
                    observer: "_onSelectedOperandIndex1"
                },

                _computedRelation: {
                    type: Number
                },



                binary: {
                    type: Boolean,
                    value: false,
                    computed: '_isBinary(_computedRelation)'
                },

                arg1: String,
                arg2: String,
                condition: String,

                initialized: Boolean,
                addressedValue: Boolean

            },

            _onSelectedOperandIndex1: function (e) {
                if (e == 0) {
                    //field
                    if (!this.apply.field) {
                        if (!this.apply.field)
                            this.set('apply.field', {});
                    }
                    this.set('apply.return', null);
                    this.set('apply.apply', null);
                } else if (e == 1) {
                    //return value
                    this.set('apply.field', null);
                    this.set('apply.return', true);
                    this.set('apply.apply', null);
                }
                else if (e == 2) {
                    // //return
                    if (!this.apply.apply)
                        this.set('apply.apply', {});
                    this.set('apply.return', null);
                    this.set('apply.field', null);
                }

            },

            _isBinary(_computedRelation) {
                let name = this._relationName(_computedRelation);
                return this._binaryRelations.indexOf(name) >= 0;
            },

            _onSelectedRelation: function (e) {
                console.error("_onSelectedRelation:" + e);
                for (let idx = 0; idx < this.relations.length; idx++) {
                    let r = this.relations[idx];
                    // delete this.apply[r];
                    if (idx === e) {
                        this.apply[r] = true;
                    } else {
                        delete this.apply[r];
                    }
                }

                this.notifyPath("apply." + this.relations[e]);

            },

            _relationDisplayName: function (index) {
                let name = this._relationName(index);
                return !!name ? this._relationNameByKey(name) : "- unconstrained -";
            },

            _relationName: function (index) {
                return index >= 0 && index < this.relations.length && this.relations[index];
                // if (index && index >= 0 && index < this.relations.length) {
                //     return this.relations[index];
                //     //return this._relationNameByKey(this.relations[index]);
                // }
                // return undefined;
            },

            _relationNameByKey: function (key) {
                if (Contracts.RELATIONS_NAMES[key]) {
                    return Contracts.RELATIONS_NAMES[key]
                } else {
                    return key;
                }
            },

            not: function (e) {
                return !(!!e);
            },

            _findRelationIndex(apply) {
                let idx = 0;
                for (let idx = 0; idx < Contracts.RELATIONS.length; idx++) {
                    let r = Contracts.RELATIONS[idx];
                    if (apply[r]) {
                        return idx;
                    }
                }
                // Contracts.RELATIONS.forEach(r=>{
                //     if(apply[r]){
                //         return idx;
                //     }
                //     idx++;
                // });
                return -1;
            },



            formulaChanged: function (e) {
                const a = this.apply;
                if (a) {
                    this._debug = JSON.stringify(a, null, ' ');
                    this._computedRelation = this._findRelationIndex(a);
                    console.log(this._computedRelation);

                    if (a.field) {
                        this.selectedOperandIndex1 = 0;
                    } else if (a.return) {
                        this.selectedOperandIndex1 = 1;
                    } else if (a.apply) {
                        this.selectedOperandIndex1 = 2;
                    }

                     
                } else {
                    this._computedRelation = -1;
                }

                // this.predicates = predicates;
            },



            // _getPredicates: function (apply) {
            //     let predicates = [];
            //     Object.keys(apply).forEach(key => {
            //         if (apply[key] === true) {
            //             if (key === 'lt')
            //                 predicates.push('<');
            //             else if (key === 'gt')
            //                 predicates.push('>');
            //             else
            //                 predicates.push(key);
            //         }
            //     });
            //     return predicates;
            // },


        });
    </script>

</dom-module>

<!-- ****************** -->

<dom-module id="contract-info">
    <style>
        :host {
            --bth-add-size: 32px;
        }

        .postcondition {
            background-color: var(--selection-md-bg);
            padding: 2px;


            margin-bottom: 10px;
            border-radius: 5px;
        }

        .btn-add {
            border-radius: 50%;
            background-color: var(--brand-color);
            color: white;
            min-width: var(--bth-add-size);
            width: var(--bth-add-size);
            max-width: var(--bth-add-size);
            padding: 0;
            height: var(--bth-add-size);
            min-height: var(--bth-add-size);
            max-height: var(--bth-add-size);
            font-size: 20px;
        }
    </style>

    <template>

        <template is="dom-if" if="[[contract]]">

            <h2 class="code">[[contract.name]]([[contract.parameters]])</h2>


            <h3>Preconditions: ([[contract.preconditions.length]])</h3>
            <template is="dom-repeat" items="[[contract.preconditions]]">
                <div class="postcondition">
                    <c-apply apply="[[item.math.apply]]"></c-apply>
                </div>
            </template>
            <paper-button raised on-tap="addPreCondition" class="btn-add">+</paper-button>

            <h3>Postconditions: ([[contract.postconditions.length]])</h3>
            <template is="dom-repeat" items="[[contract.postconditions]]">
                <div class="postcondition">
                    <c-apply apply="[[item.math.apply]]"></c-apply>
                </div>
            </template>
            <paper-button raised on-tap="addPostCondition" class="btn-add">+</paper-button>
        </template>



    </template>



    <script>



        Polymer({
            is: 'contract-info',
            properties: {
                contract: {
                    type: Object,
                    observer: '_onContractChanged'
                },

            },

            _onContractChanged: function (c) {
                // console.log(c);
            },

            addPostCondition: function () {
                this.push("contract.postconditions", { math: { apply: { return: true } } });
            },

            addPreCondition: function () {
                this.push("contract.preconditions", { math: { apply: {} } });
            }
        });


    </script>


</dom-module>